
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <meta name="theme-color" content="#000000">
    <title>0RA1N</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Monomaniac+One&display=swap');
        
        @font-face {
            font-family: 'MonomaniacOne';
            src: url('./MonomaniacOne-Regular.ttf') format('truetype');
            font-display: swap;
        }
        
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'MonomaniacOne', 'Monomaniac One', 'Courier New', monospace;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: none;
        }
        
        #crtCanvas {
            display: block;
            background: #000;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <canvas id="crtCanvas"></canvas>

    <script>
        // Seeded random number generator
        class SeededRandom {
            constructor(seed) {
                this.seed = seed;
            }
            
            next() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }
            
            randInt(min, max) {
                return Math.floor(this.next() * (max - min + 1)) + min;
            }
            
            randFloat(min, max) {
                return this.next() * (max - min) + min;
            }
        }

        class BinaryRainGame {
            constructor() {
                this.audioStarted = false;
                this.gameCanvas = document.getElementById('gameCanvas');
                this.gameCtx = this.gameCanvas.getContext('2d');
                this.crtCanvas = document.getElementById('crtCanvas');

                this.isIOS = (/iPad|iPhone|iPod/.test(navigator.userAgent));
                
                // Initialize CRT shader
                this.initCRTShader();
                
                // Audio setup
                this.sounds = {
                    splish: null,
                    explosion: null
                };
                this.loadSounds();
                
                // Get seed from URL parameter or generate random one
                const urlParams = new URLSearchParams(window.location.search);
                this.seed = urlParams.get('seed') ? parseInt(urlParams.get('seed')) : Math.floor(Math.random() * 1000000);
                this.rng = new SeededRandom(this.seed);
                
                // Game constants
                this.BASE_WIDTH = 1080;
                this.BASE_HEIGHT = 2400;
                this.STRAIN_MIN_SIZE = 3;
                this.STRAIN_MAX_SIZE = 6;
                this.MIN_BASE_SPEED = 100;
                this.MAX_BASE_SPEED = 160;
                this.TOTAL_STRAINS = 20;
                this.TOTAL_RAINDROPS = 120;
                this.BASE_DIGIT_SIZE = 80;
                this.DIGIT_ALPHA = 0.35;

                // Colors
                this.colorTitle = 'gray';
                this.colorStart = 'cyan';
                this.colorSeed = 'cyan';
                this.colorScore = 'yellow';

                // Text sizes
                this.sizeTitle = 200;
                this.sizeMenu = 80;
                this.sizeSeed = 80;
                this.sizeScore = 80;
                
                // Scale factor for responsive sizing
                this.scale = 1;
                this.width = this.BASE_WIDTH;
                this.height = this.BASE_HEIGHT;
                this.digitSize = this.BASE_DIGIT_SIZE;
                
                // Game state - start with start screen
                this.gameMode = "start";
                this.score = 0;
                this.strains = [];
                this.raindrops = [];
                this.explosions = [];
                
                this.lastTime = 0;
                this.animTime = 0;
                
                this.init();
            }
            
            initCRTShader() {
                const gl = this.crtCanvas.getContext('webgl') || this.crtCanvas.getContext('experimental-webgl');
                if (!gl) {
                    console.error('WebGL not supported');
                    return;
                }
                
                this.gl = gl;
                
                // Vertex shader
                const vertexShaderSource = `
                    attribute vec4 a_position;
                    attribute vec2 a_texCoord;
                    varying vec2 v_texCoord;
                    
                    void main() {
                        gl_Position = a_position;
                        v_texCoord = a_texCoord;
                    }
                `;
                
                // Fragment shader with CRT effect
                const fragmentShaderSource = `
                    precision highp float;
                    
                    varying vec2 v_texCoord;
                    uniform float u_time;
                    uniform vec2 u_resolution;
                    uniform sampler2D u_texture;
                    
                    const float M_PI = 3.14159265;
                    
                    float rnd(vec2 c) {
                        return fract(sin(dot(c.xy, vec2(12.9898,78.233))) * 43758.5453);
                    }
                    
                    vec3 hsl2rgb(vec3 c) {
                        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                    }
                    
                    vec3 rgbDistortion(vec2 uv, float offset) {
                        vec3 color;
                        color.r = texture2D(u_texture, uv + vec2(offset, 0.0)).r;
                        color.g = texture2D(u_texture, uv).g;
                        color.b = texture2D(u_texture, uv - vec2(offset, 0.0)).b;
                        return color;
                    }
                    
                    float calculateLightFactor(vec2 uv, float iTime) {
                        float intensity = 1.5;
                        float ambient_light = 0.25;
                        
                        float lightX = 0.5 + sin(iTime * 1.75) * 0.35;
                        vec2 lightPos = vec2(lightX, 0.2);
                        
                        vec2 lightVector = uv - lightPos;
                        float scaledDistance = length(lightVector);
                        
                        float lightFalloff = pow(clamp(1.0 - (scaledDistance / 1.5), 0.0, 1.0), 0.85);
                        
                        return mix(ambient_light, 1.0 + intensity, lightFalloff);
                    }
                    
                    vec3 applyCRTEffect(vec2 uv, float bSize, vec3 bColor, bool isFrame, float fSize) {
                        float iTime = u_time;
                        vec2 iResolution = u_resolution;
                        
                        // Default CRT parameters
                        float grilleLvl = 0.95;
                        float grilleDensity = 800.0;
                        float scanlineLvl = 0.8;
                        float scanlines = 1.0;
                        float rgbOffset = 0.001;
                        float noiseLevel = 0.0;
                        float flicker = 0.05;
                        float glassTint = 0.2;
                        float glassHue = 0.6;
                        float glassSat = 0.3;
                        float screenTint = 0.2;
                        float screenHue = 0.0;
                        float screenSat = 1.0;
                        float vignetteStart = 0.5;
                        float vignetteLvl = 20.0;
                        float hSync = 0.01;
                        float lightSpeed = 1.0;
                        
                        // Configure parameters for horizontal sync wave
                        float time = iTime * 5.0;
                        float size = mix(0.0, hSync, 0.1);
                        
                        float cyclePeriod = 2.0;
                        float randomOffset = fract(sin(floor(iTime / cyclePeriod) * 12345.67) * 43758.5453);
                        float actualCyclePeriod = cyclePeriod + randomOffset;
                        float cyclePosition = fract(iTime / actualCyclePeriod);
                        
                        float waveDuration = 0.15;
                        float waveStrength = 0.0;
                        
                        if (cyclePosition < waveDuration) {
                            float normalizedTime = cyclePosition / waveDuration;
                            waveStrength = sin(normalizedTime * 3.14159) * size;
                        }
                        
                        float hWave = sin(uv.y * 10.0 + time) * waveStrength;
                        vec3 color;
                        
                        bool isBorder = 
                            (uv.x < bSize || uv.x > 1.0 - bSize || 
                             uv.y < bSize || uv.y > 1.0 - bSize);
                        
                        vec2 screenUV = (uv - vec2(bSize, bSize)) / (1.0 - 2.0 * bSize);
                        if (isBorder && bSize > 0.0) {
                            if (screenUV.x < 0.0 || screenUV.x > 1.0 || screenUV.y < 0.0 || screenUV.y > 1.0) {
                                color = bColor;
                            } else {
                                color = rgbDistortion(screenUV, rgbOffset);
                            }
                        } else {
                            screenUV.x += hWave;
                            if (screenUV.x < 0.0 || screenUV.x > 1.0 || screenUV.y < 0.0 || screenUV.y > 1.0) {
                                color = bColor;
                            } else {
                                color = rgbDistortion(screenUV, rgbOffset);
                            }
                        }
                        
                        // FX Aperture Grille
                        if (grilleLvl > 0.0) {
                            float grillePattern = sin(uv.x * grilleDensity * 3.14159);
                            grillePattern = grilleLvl + (1.0 - grilleLvl) * grillePattern;
                            color *= (0.5 + 0.5 * grillePattern);
                        }
                        
                        // FX Scanlines
                        if (scanlineLvl > 0.05) {
                            float scanlinePattern = sin(uv.y * iResolution.y * 3.14159 / scanlines);
                            color *= (scanlineLvl + (1.0 - scanlineLvl) * scanlinePattern);
                        }
                        
                        // FX Noise
                        if (noiseLevel > 0.0) {
                            float timeFactor = iTime * 1.0;
                            float noise = rnd(uv + timeFactor);
                            color += noise * noiseLevel * 0.5;
                        }
                        
                        // FX Screen tint
                        if (screenTint > 0.0) {
                            float l = dot(color, vec3(0.2126, 0.7152, 0.0722));
                            vec3 screen = hsl2rgb(vec3(screenHue, screenSat, l));
                            color = mix(color, screen, screenTint);
                        }
                        
                        // FX Glass tint
                        if (glassTint > 0.0) {
                            float t = 0.5 + 0.5 * uv.y;
                            vec3 tintColor = hsl2rgb(vec3(glassHue, glassSat, t));
                            color += tintColor * glassTint;
                        }
                        
                        // FX Flicker
                        if (flicker > 0.0) {
                            float f = 1.0 + 0.25 * sin(iTime * 60.0) * flicker;
                            color *= f;
                        }
                        
                        return color;
                    }
                    
                    void main() {
                        float iTime = u_time;
                        vec2 iResolution = u_resolution;
                        
                        vec2 uv = gl_FragCoord.xy / iResolution.xy;
                        
                        // FX Rumble
                        float hash = fract(sin(floor(iTime / 7.0) * 43758.5453));
                        float interval = 7.0 + hash * 6.0;
                        float rumbleDuration = 1.0;
                        float rumbleDim = 0.0;
                        
                        if (rumbleDuration > 0.0) {
                            float rumbleStrength = 0.0;
                            
                            float currentIntervalStart = floor(iTime / interval) * interval;
                            float phase = iTime - currentIntervalStart;
                            
                            if (phase < rumbleDuration) {
                                rumbleStrength = sin(phase * 3.14159 / rumbleDuration);
                                rumbleDim = 0.05 * rumbleStrength;
                            }
                            
                            float maxOffset = 3.0;
                            vec2 rumbleOffset = vec2(
                                sin(iTime * 20.0 + 0.3) * cos(iTime * 13.0),
                                cos(iTime * 17.0 - 0.7) * sin(iTime * 11.0)
                            ) * rumbleStrength * maxOffset / iResolution;
                            //uv += rumbleOffset;
                        }
                        
                        vec2 center = vec2(0.5, 0.5);
                        float alpha = 1.0;
                        float distanceFromCenter = length(uv - center);
                        vec2 pxSize = 1.0 / iResolution.xy;
                        
                        float curveStrength = 0.2;
                        float curveDistance = 5.0;
                        
                        uv += (uv - center) * pow(distanceFromCenter, curveDistance) * curveStrength;
                        
                        vec3 bColor = hsl2rgb(vec3(0.0, 0.0, 0.0));
                        
                        float frameSize = 0.0;
                        float borderSize = 0.0;
                        float frame = frameSize * pxSize.x;
                        float border = borderSize * pxSize.x;
                        vec2 suv = (uv - vec2(frame, frame)) / (1.0 - 2.0 * frame);
                        
                        vec3 color;
                        
                        bool isFrame = (uv.x < frame || uv.x > (1.0 - frame) ||
                                        uv.y < frame || uv.y > (1.0 - frame));
                        
                        if (isFrame) {
                            float frameLight = 0.0;
                            if (frameLight == 0.0) alpha = 0.0;
                            
                            float frameVal = 100.0;
                            float nX = frameVal / iResolution.x;
                            float nY = frameVal / iResolution.y;
                            float intensity = 0.0;
                            
                            float distX = min(uv.x, 1.0-uv.x);
                            float distY = min(uv.y, 1.0-uv.y);
                            float minDist = min(distX, distY);
                            
                            intensity = mix(frameLight, 0.0, minDist / max(nX, nY) * 4.0);
                            
                            float frameHue = 0.025;
                            float frameSat = 0.1;
                            color = hsl2rgb(vec3(frameHue, frameSat, intensity));
                            
                            float frameGrain = 0.15;
                            color *= 1.0 - frameGrain * rnd(suv);
                            
                            float lightFactor = calculateLightFactor(uv, iTime);
                            vec3 lightColor = vec3(1.0, 0.98, 0.95);
                            color *= lightColor * lightFactor;
                        } else {
                            color = applyCRTEffect(suv, border, bColor, isFrame, frameSize);
                        }
                        
                        // FX Vignette
                        if (!isFrame) {
                            uv *= (1.0 - uv.yx);
                            color *= pow(uv.x * uv.y * 20.0, 0.25);
                        }
                        
                        // FX Light Source
                        float lightSpeed = 1.0;
                        if (lightSpeed > 0.0 && !isFrame) {
                            float lightFactor = calculateLightFactor(gl_FragCoord.xy / iResolution.xy, iTime * lightSpeed);
                            vec3 lightColor = vec3(1.0, 0.98, 0.95);
                            color *= lightColor * lightFactor;
                        }
                        
                        color -= rumbleDim;
                        
                        gl_FragColor = vec4(color, alpha);
                    }
                `;
                
                // Create shaders
                const vertexShader = this.createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = this.createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
                
                if (!vertexShader || !fragmentShader) {
                    console.error('Failed to create shaders');
                    return;
                }
                
                // Create program
                this.shaderProgram = this.createProgram(gl, vertexShader, fragmentShader);
                if (!this.shaderProgram) {
                    console.error('Failed to create shader program');
                    return;
                }
                
                // Set up geometry
                const positions = [
                    -1, -1,  0, 0,  // Bottom left
                    1, -1,  1, 0,  // Bottom right
                    -1,  1,  0, 1,  // Top left
                    -1,  1,  0, 1,  // Top left
                    1, -1,  1, 0,  // Bottom right
                    1,  1,  1, 1,  // Top right
                ];
                
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                
                const positionLocation = gl.getAttribLocation(this.shaderProgram, 'a_position');
                const texCoordLocation = gl.getAttribLocation(this.shaderProgram, 'a_texCoord');
                
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 16, 0);
                
                gl.enableVertexAttribArray(texCoordLocation);
                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 16, 8);
                
                // Get uniform locations
                this.timeLocation = gl.getUniformLocation(this.shaderProgram, 'u_time');
                this.resolutionLocation = gl.getUniformLocation(this.shaderProgram, 'u_resolution');
                this.textureLocation = gl.getUniformLocation(this.shaderProgram, 'u_texture');
                
                // Create texture for game canvas
                this.gameTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.gameTexture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                
                this.startTime = Date.now();
            }
            
            createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }
            
            createProgram(gl, vertexShader, fragmentShader) {
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Program linking error:', gl.getProgramInfoLog(program));
                    gl.deleteProgram(program);
                    return null;
                }
                
                return program;
            }
            
            renderCRT() {
                if (!this.gl || !this.shaderProgram) return;

                const gl = this.gl;

                // Keep CRT canvas size managed by resizeCanvas() so aspect ratio matches BASE_WIDTH/BASE_HEIGHT
                if (this.crtCanvas.width !== this.width || this.crtCanvas.height !== this.height) {
                    this.crtCanvas.width = this.width;
                    this.crtCanvas.height = this.height;
                }

                // Always set viewport to CRT canvas size
                gl.viewport(0, 0, this.crtCanvas.width, this.crtCanvas.height);

                // Update game texture from hidden game canvas
                gl.bindTexture(gl.TEXTURE_2D, this.gameTexture);
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.gameCanvas);

                //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.gameCanvas);

                gl.useProgram(this.shaderProgram);

                // Update uniforms
                const time = (Date.now() - this.startTime) / 1000;
                gl.uniform1f(this.timeLocation, time);

                // Use CRT canvas resolution for shader effects
                gl.uniform2f(this.resolutionLocation, this.crtCanvas.width, this.crtCanvas.height);

                // Bind game texture
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.gameTexture);
                gl.uniform1i(this.textureLocation, 0);

                // Draw full screen quad (gameCanvas will be stretched to CRT canvas)
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }

            loadSounds() {
                // Try to load local sound files
                const loadSound = (filename) => {
                    return new Promise((resolve) => {
                        const audio = new Audio();
                        audio.addEventListener('canplaythrough', () => resolve(audio), { once: true });
                        audio.addEventListener('error', () => resolve(null), { once: true });
                        audio.src = `./${filename}`;
                        audio.load();
                    });
                };
                
                // Load sounds asynchronously
                loadSound('fx-rain.ogg').then(audio => {
                    // Keep the original audio for fallback
                    this.sounds.rain = audio;
                    
                    // Create Web Audio context for seamless looping
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    // Load the audio buffer
                    fetch('./fx-rain.ogg')
                        .then(response => response.arrayBuffer())
                        .then(data => this.audioContext.decodeAudioData(data))
                        .then(buffer => {
                            this.rainBuffer = buffer;
                            if (audio) {
                                audio.loop = true;
                                audio.volume = 0.3;
                            }
                        })
                        .catch(console.error);
                });

                loadSound('music.ogg').then(audio => {
                    this.sounds.music = audio;
                    if (audio) {
                        audio.loop = true;
                        audio.volume = 0.5; // Adjust volume as needed
                    }
                });

                loadSound('fx-splish.ogg').then(audio => {
                    this.sounds.splish = audio;
                });
                
                loadSound('fx-explosion.ogg').then(audio => {
                    this.sounds.explosion = audio;
                });

                loadSound('fx-huh.ogg').then(audio => {
                    this.sounds.gameover = audio;
                });
            }

            startAudio() {
                if (!this.audioStarted) {
                    if (this.rainBuffer && this.audioContext) {
                        // Use Web Audio API for seamless looping
                        this.rainSource = this.audioContext.createBufferSource();
                        this.rainSource.buffer = this.rainBuffer;
                        this.rainSource.loop = true;
                        
                        const gainNode = this.audioContext.createGain();
                        gainNode.gain.value = 0.3;
                        
                        this.rainSource.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        this.rainSource.start(0);
                        this.audioStarted = true;
                        console.log('Rain sound started with Web Audio API');
                    } else if (this.sounds.rain) {
                        // Fallback to regular audio
                        this.sounds.rain.play().then(() => {
                            console.log('Rain sound started with fallback method');
                            this.audioStarted = true;
                        }).catch(console.error);
                    }
                }
            }

            startGameMusic() {
                if (this.sounds.music && this.sounds.music.paused) {
                    this.sounds.music.play().catch(() => {});
                }
            }

            stopGameMusic() {
                if (this.sounds.music && !this.sounds.music.paused) {
                    this.sounds.music.pause();
                    this.sounds.music.currentTime = 0; // Reset to beginning
                }
            }
            
            playSound(soundName) {
                const sound = this.sounds[soundName];
                if (sound) {
                    sound.currentTime = 0;
                    sound.play().catch(() => {}); // Ignore play errors
                }
            }
            
            init() {
                this.resizeCanvas();

                // Keyboard input
                document.addEventListener('keydown', (e) => this.handleInput(e));

                // Touch/mouse input
                if (!this.isIOS) this.crtCanvas.addEventListener('click', (e) => this.handleTap(e));
                this.crtCanvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handleTap(touch);
                }, { passive: false });
                // Prevent scrolling on iOS especially
                this.crtCanvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                }, { passive: false });

                window.addEventListener('resize', () => this.resizeCanvas());

                this.updateURL();
                this.gameLoop();

                console.log(`Game seed: ${this.seed}`);
                console.log(`Share this game: ${window.location.origin}${window.location.pathname}?seed=${this.seed}`);
            }

            handleTap(pos) {
                const rect = this.crtCanvas.getBoundingClientRect();
                const x = pos.clientX - rect.left;
                const y = pos.clientY - rect.top;

                this.startAudio();

                if (this.gameMode === "start") {
                    this.startNewGame();
                    return;
                }

                if (this.gameMode === "gameover") {
                    const centerY = this.height / 2;
                    if (y < centerY + 80) {
                        this.startNewGame();
                    } else {
                        this.restart();
                    }
                    return;
                }

                if (this.gameMode !== "play") return;

                if (x < this.width / 2) {
                    this.handleVirtualKey("1");
                } else {
                    this.handleVirtualKey("0");
                }
            }

            handleVirtualKey(key) {
                for (const strain of this.strains) {
                    if (strain.destroyTimer > 0) continue;

                    const currentDigit = strain.digits[strain.highlight];
                    if (key === currentDigit.value) {
                        strain.highlight--;
                        this.playSound('splish');
                        this.createSuccessEffect(strain.x, strain.getHighlightY());

                        if (strain.highlight < 0) {
                            this.scoreUp(strain);
                        }
                    } else {
                        strain.reset();
                    }
                }
            }
            
            updateURL() {
                const url = new URL(window.location);
                url.searchParams.set('seed', this.seed);
                window.history.replaceState({}, '', url);
            }
            
            startNewGame() {
                this.startGameMusic();
                this.seed = Math.floor(Math.random() * 1000000);
                this.rng = new SeededRandom(this.seed);
                this.updateURL();
                this.gameMode = "play";
                this.score = 0;
                this.strains = [];
                this.explosions = [];
                console.log(`New game seed: ${this.seed}`);
            }
            
            resizeCanvas() {
                const windowHeight = window.innerHeight - 20; // Small margin
                const windowWidth = window.innerWidth - 20;
                
                // Calculate scale to fit height while maintaining aspect ratio
                const scaleByHeight = windowHeight / this.BASE_HEIGHT;
                const scaleByWidth = windowWidth / this.BASE_WIDTH;
                this.scale = Math.min(scaleByHeight, scaleByWidth);
                
                this.width = this.BASE_WIDTH * this.scale;
                this.height = this.BASE_HEIGHT * this.scale;
                this.digitSize = this.BASE_DIGIT_SIZE * this.scale;
                
                // Resize game canvas
                this.gameCanvas.width = this.width;
                this.gameCanvas.height = this.height;
                
                // Resize CRT canvas
                this.crtCanvas.width = this.width;
                this.crtCanvas.height = this.height;
                
                // Update canvas drawing properties with font fallback
                this.gameCtx.font = `${this.digitSize}px "MonomaniacOne", "Monomaniac One", "Courier New", monospace`;
                this.gameCtx.textAlign = 'left';
                this.gameCtx.textBaseline = 'top';
            }
            
            findValidX() {
                // Create array to track occupied pixels
                const pixels = new Array(Math.floor(this.width)).fill(true);
                
                // Mark occupied positions
                for (const strain of this.strains) {
                    const maxX = Math.min(strain.x + this.digitSize, this.width);
                    for (let i = strain.x; i < maxX; i++) {
                        if (strain.getY() < this.height / 2) {
                            pixels[i] = false;
                        }
                    }
                }
                
                // Find valid positions
                const possibles = [];
                for (let x = 0; x < pixels.length; x++) {
                    if (this.isValidPosition(pixels, x)) {
                        possibles.push(x);
                    }
                }
                
                if (possibles.length === 0) return -1;
                return possibles[this.rng.randInt(0, possibles.length - 1)];
            }
            
            isValidPosition(pixels, x) {
                if (x > this.width - this.digitSize) return false;
                
                for (let i = x; i < x + this.digitSize; i++) {
                    if (i >= pixels.length || !pixels[i]) return false;
                }
                return true;
            }
            
            handleInput(event) {
                this.startAudio();
                if (this.gameMode === "start") {
                    if (event.key.toLowerCase() === 's') {
                        this.startNewGame();
                    }
                    return;
                }
                
                if (this.gameMode === "gameover") {
                    if (event.key.toLowerCase() === 'r') {
                        this.restart();
                    } else if (event.key.toLowerCase() === 's') {
                        this.startNewGame();
                    }
                    return;
                }
                
                if (this.gameMode !== "play") return;
                
                let key = event.key;
                
                // Handle numpad keys
                if (key === 'Numpad0') key = '0';
                if (key === 'Numpad1') key = '1';
                
                if (key === '0' || key === '1') {
                    for (const strain of this.strains) {
                        if (strain.destroyTimer > 0) continue;
                        
                        const currentDigit = strain.digits[strain.highlight];
                        if (key === currentDigit.value) {
                            strain.highlight--;
                            // Play success sound effect
                            this.playSound('splish');
                            this.createSuccessEffect(strain.x, strain.getHighlightY());
                            
                            if (strain.highlight < 0) {
                                this.scoreUp(strain);
                            }
                        } else {
                            strain.reset();
                        }
                    }
                }
            }
            
            createSuccessEffect(x, y) {
                // Create a small visual effect for successful key press
                // exclude iOS devices due to performance issues
                if (this.isIOS) return;
                this.explosions.push(new Explosion(x, y, '+1'));
            }
            
            scoreUp(strain) {
                this.score += strain.strainSize;
                strain.destroyTimer = this.DIGIT_ALPHA;
                
                // Play explosion sound effect
                this.playSound('explosion');
                
                // Create explosion effects
                for (const digit of strain.digits) {
                    this.explosions.push(new Explosion(digit.x, digit.y, '•'));
                }
            }
            
            restart() {
                // Reset RNG with same seed
                this.rng = new SeededRandom(this.seed);
                this.gameMode = "play";
                this.score = 0;
                this.strains = [];
                this.explosions = [];
                this.startGameMusic();
            }
            
            gameOver() {
                this.gameMode = "gameover";
                this.stopGameMusic();
                this.playSound('gameover');
                // Start destruction animation for all strains
                for (const strain of this.strains) {
                    if (strain.destroyTimer <= 0) {  // Only if not already destroying
                        strain.destroyTimer = this.DIGIT_ALPHA;  // Same timer value used elsewhere
                        
                        // Optional: Create explosion effects without scoring
                        for (const digit of strain.digits) {
                            this.explosions.push(new Explosion(digit.x, digit.y, '•'));
                        }
                    }
                }
            }
            
            update(deltaTime) {
                this.animTime += deltaTime;
                
                // Update explosions (always)
                for (let i = this.explosions.length - 1; i >= 0; i--) {
                    this.explosions[i].update(deltaTime);
                    if (this.explosions[i].alpha <= 0) {
                        this.explosions.splice(i, 1);
                    }
                }
                
                // Update strains (always, for destruction animations)
                for (let i = this.strains.length - 1; i >= 0; i--) {
                    const strain = this.strains[i];
                    strain.update(deltaTime, this.height, this.animTime);
                    
                    if (strain.destroyTimer === 0) {
                        this.strains.splice(i, 1);
                    } else if (strain.gameover && this.gameMode === "play") {
                        // Only trigger gameover if we're actually playing
                        this.gameOver();
                        return;
                    }
                }
                
                // Create raindrops (always)
                while (this.raindrops.length < this.TOTAL_RAINDROPS) {
                    this.raindrops.push(new Raindrop(this.width, this.height, this.digitSize, this.rng));
                }
                
                // Update raindrops (always)
                for (const raindrop of this.raindrops) {
                    raindrop.update(deltaTime);
                }
                
                // Early return if not in play mode - everything below is play-only logic
                if (this.gameMode !== "play") return;
                
                // Create new strains (play mode only)
                while (this.strains.length < this.TOTAL_STRAINS) {
                    let x = this.rng.randInt(0, this.width - this.digitSize);
                    if (this.strains.length > 1) {
                        x = this.findValidX();
                    }
                    if (x > -1) {
                        this.strains.push(new Strain(x, this.STRAIN_MIN_SIZE, this.STRAIN_MAX_SIZE, 
                        this.MIN_BASE_SPEED, this.MAX_BASE_SPEED, this.digitSize, this.scale, this.rng));
                    } else {
                        break;
                    }
                }
            }
            
            drawText(text, x, y, color, size = null, align = 'left') {
                const oldFont = this.gameCtx.font;
                const oldAlign = this.gameCtx.textAlign;
                
                if (size) {
                    this.gameCtx.font = `${size * this.scale}px "MonomaniacOne", "Monomaniac One", "Courier New", monospace`;
                }
                this.gameCtx.textAlign = align;
                this.gameCtx.fillStyle = color;
                this.gameCtx.fillText(text, x, y);
                
                this.gameCtx.font = oldFont;
                this.gameCtx.textAlign = oldAlign;
            }
            
            render() {
                // Clear game canvas
                this.gameCtx.fillStyle = 'black';
                this.gameCtx.fillRect(0, 0, this.width, this.height);
                
                // Render raindrops
                //this.gameCtx.fillStyle = 'rgba(255, 255, 0, 0.2)';
                for (const raindrop of this.raindrops) {
                    raindrop.render(this.gameCtx);
                }
                
                // Render strains
                for (const strain of this.strains) {
                    strain.render(this.gameCtx);
                }
                
                // Render explosions
                for (const explosion of this.explosions) {
                    explosion.render(this.gameCtx);
                }
                
                // Render UI elements on canvas
                
                // Score
                this.drawText(this.score.toString(), this.width - 20, this.height - this.sizeScore/2, this.colorScore, this.sizeScore, 'right');
                
                // Start screen
                if (this.gameMode === "start" || this.gameMode === "gameover") {
                    // 0RA1N title
                    this.drawText('0RA1N', this.width / 2, this.height / 2 - 150, this.colorTitle, this.sizeTitle, 'center');
                    
                    // Start instruction
                    let y = this.height / 2;
                    this.drawText('[S]tart', this.width / 2, y, this.colorStart, this.sizeMenu, 'center');
                    y += this.sizeMenu;
                    if (this.gameMode === "gameover"){
                        this.drawText('[R]estart with', this.width / 2, y, this.colorStart, this.sizeMenu, 'center');
                        y += this.sizeMenu / 2;
                    }

                    // Seed info
                    this.drawText(`Seed: ${this.seed}`, this.width / 2, y, this.colorSeed, this.sizeSeed, 'center');
                }
                
                // Render CRT effect
                this.renderCRT();
            }
            
            gameLoop(currentTime = 0) {
                const deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;
                
                this.update(deltaTime);
                this.render();
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }
        }
        
        class Strain {
            constructor(x, minSize, maxSize, minSpeed, maxSpeed, digitSize, scale, rng) {
                this.x = x;
                this.speed = (rng.randFloat(minSpeed, maxSpeed)) * scale;
                this.strainSize = rng.randInt(minSize, maxSize);
                this.gameover = false;
                this.destroyTimer = -1;
                this.digits = [];
                this.highlight = this.strainSize - 1;
                this.currentAnim = this.strainSize;
                this.animMultiplier = rng.randFloat(4, 12);
                
                // Create digits
                for (let i = 0; i < this.strainSize; i++) {
                    this.digits.push({
                        value: rng.next() < 0.5 ? '0' : '1',
                        x: x,
                        y: (i * digitSize) - this.strainSize * digitSize
                    });
                }
            }
            
            getY() {
                return this.digits[0].y;
            }
            
            getHighlightY() {
                return this.digits[this.highlight] ? this.digits[this.highlight].y : this.getY();
            }
            
            getDigitColor(i, alpha = 1) {
                const baseAlpha = 0.3 * alpha;
                let a = baseAlpha;
                
                if (i > this.highlight) {
                    return `rgba(255, 255, 255, ${0.75 * alpha})`;
                }
                
                if (i === Math.floor(this.currentAnim)) {
                    a = baseAlpha + 0.2;
                }
                
                if (i === this.strainSize - 1) {
                    a += 0.2;
                }
                
                return `rgba(0, 255, 255, ${a})`;
            }
            
            reset() {
                this.highlight = this.strainSize - 1;
            }
            
            update(deltaTime, windowHeight, globalAnimTime) {
                this.currentAnim += deltaTime * this.animMultiplier;
                if (this.currentAnim > this.strainSize) {
                    this.currentAnim = 0;
                }
                
                for (let i = 0; i < this.digits.length; i++) {
                    const digit = this.digits[i];
                    digit.y += this.speed * deltaTime;
                    digit.x += (Math.random() - 0.5) * 0.05;
                    
                    if (this.destroyTimer > 0) {
                        digit.y += (Math.random() - 0.5) * 10;
                        digit.x += (Math.random() - 0.5) * 10;
                        this.destroyTimer -= 0.0025;
                        if (this.destroyTimer < 0) {
                            this.destroyTimer = 0;
                        }
                    }
                    
                    if (digit.y > windowHeight && !this.gameover) {
                        this.gameover = true;
                    }
                }
            }
            
            render(ctx) {
                for (let i = 0; i < this.digits.length; i++) {
                    const digit = this.digits[i];
                    const alpha = this.destroyTimer > 0 ? this.destroyTimer : 1;
                    ctx.fillStyle = this.getDigitColor(i, alpha);
                    ctx.fillText(digit.value, digit.x, digit.y);
                }
            }
        }
        
        class Raindrop {
            constructor(windowWidth, windowHeight, digitSize, rng) {
                this.windowWidth = windowWidth;
                this.windowHeight = windowHeight;
                this.digitSize = digitSize;
                this.speed = rng.randFloat(300, 700);
                this.rng = rng;
                this.reset();
            }
            
            reset() {
                this.x = this.rng.randFloat(0, this.windowWidth - this.digitSize);
                this.y = -this.digitSize;
                this.i = this.rng.randFloat(1, 14);
                this.size = this.rng.randFloat(2, 5);
            }
            
            update(deltaTime) {
                this.y += this.speed * deltaTime;
                if (this.y > this.windowHeight) {
                    this.reset();
                }
            }
            
            render(ctx) {
                if (this.i > 0) {
                    ctx.fillStyle = `rgb(${this.i}, ${this.i}, ${this.i})`;
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                }
            }
        }
        
        class Explosion {
            constructor(x, y, char = '•') {
                this.x = x;
                this.y = y;
                this.char = char;
                this.i = 200;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
            }
            
            update(deltaTime) {
                this.x += this.vx;
                this.y += this.vy;
                this.i -= 10;
            }
            
            render(ctx) {
                if (this.i > 0) {
                    if (this.isIOS) return;
                    ctx.fillStyle = `rgb(${this.i}, ${this.i}, ${this.i})`;
                    ctx.fillText(this.char, this.x, this.y);
                }
            }
        }
        
        // Start the game
        const game = new BinaryRainGame();

        if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
            navigator.serviceWorker.register("service-worker.js")
            .then((reg) => console.log("Service worker registered:", reg.scope))
            .catch((err) => console.error("Service worker failed:", err));
        });
        }
    </script>
</body>
</html>