<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>0RA1N</title>
    <link rel="manifest" href="./manifest.json">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Monomaniac+One&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Monomaniac One', 'Courier New', monospace;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
        }
    </style>
</head>
<body>
    <div id="gameContainer"></div>

    <script>
        // CRT Filter for PixiJS
        class CRTFilter extends PIXI.Filter {
            constructor() {
                const fragmentShader = `
                    precision highp float;
                    
                    varying vec2 vTextureCoord;
                    uniform sampler2D uSampler;
                    uniform float uTime;
                    uniform vec2 uResolution;
                    
                    const float M_PI = 3.14159265;
                    const float CURVE_STRENGTH = 0.15;
                    const float CURVE_DISTANCE = 5.0;
                    
                    float rnd(vec2 c) {
                        return fract(sin(dot(c.xy, vec2(12.9898,78.233))) * 43758.5453);
                    }
                    
                    vec3 hsl2rgb(vec3 c) {
                        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                    }
                    
                    vec3 rgbDistortion(vec2 uv, float offset) {
                        vec3 color;
                        color.r = texture2D(uSampler, uv + vec2(offset, 0.0)).r;
                        color.g = texture2D(uSampler, uv).g;
                        color.b = texture2D(uSampler, uv - vec2(offset, 0.0)).b;
                        return color;
                    }
                    
                    float calculateLightFactor(vec2 uv, float iTime) {
                        float intensity = 1.5;
                        float ambient_light = 0.25;
                        
                        float lightX = 0.5 + sin(iTime * 1.75) * 0.35;
                        vec2 lightPos = vec2(lightX, 0.2);
                        
                        vec2 lightVector = uv - lightPos;
                        float scaledDistance = length(lightVector);
                        
                        float lightFalloff = pow(clamp(1.0 - (scaledDistance / 1.5), 0.0, 1.0), 0.85);
                        
                        return mix(ambient_light, 1.0 + intensity, lightFalloff);
                    }
                    
                    void main() {
                        float iTime = uTime;
                        vec2 iResolution = uResolution;
                        
                        vec2 uv = vTextureCoord;
                        
                        // FX Rumble
                        float hash = fract(sin(floor(iTime / 7.0) * 43758.5453));
                        float interval = 7.0 + hash * 6.0;
                        float rumbleDuration = 1.0;
                        float rumbleDim = 0.0;
                        
                        if (rumbleDuration > 0.0) {
                            float rumbleStrength = 0.0;
                            
                            float currentIntervalStart = floor(iTime / interval) * interval;
                            float phase = iTime - currentIntervalStart;
                            
                            if (phase < rumbleDuration) {
                                rumbleStrength = sin(phase * 3.14159 / rumbleDuration);
                                rumbleDim = 0.05 * rumbleStrength;
                            }
                        }
                        
                        vec2 center = vec2(0.5, 0.5);
                        float distanceFromCenter = length(uv - center);
                        
                        // Screen curvature with reduced strength
                        uv += (uv - center) * pow(distanceFromCenter, CURVE_DISTANCE) * CURVE_STRENGTH;
                        
                        // Horizontal sync wave
                        float time = iTime * 5.0;
                        float size = 0.001;
                        
                        float cyclePeriod = 2.0;
                        float randomOffset = fract(sin(floor(iTime / cyclePeriod) * 12345.67) * 43758.5453);
                        float actualCyclePeriod = cyclePeriod + randomOffset;
                        float cyclePosition = fract(iTime / actualCyclePeriod);
                        
                        float waveDuration = 0.15;
                        float waveStrength = 0.0;
                        
                        if (cyclePosition < waveDuration) {
                            float normalizedTime = cyclePosition / waveDuration;
                            waveStrength = sin(normalizedTime * 3.14159) * size;
                        }
                        
                        float hWave = sin(uv.y * 10.0 + time) * waveStrength;
                        uv.x += hWave;
                        
                        // Check if out of bounds
                        vec3 color;
                        if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
                            color = vec3(0.0);
                        } else {
                            // RGB distortion
                            float rgbOffset = 0.001;
                            color = rgbDistortion(uv, rgbOffset);
                        }
                        
                        // FX Aperture Grille
                        float grilleLvl = 0.95;
                        float grilleDensity = 800.0;
                        if (grilleLvl > 0.0) {
                            float grillePattern = sin(vTextureCoord.x * grilleDensity * 3.14159);
                            grillePattern = grilleLvl + (1.0 - grilleLvl) * grillePattern;
                            color *= (0.5 + 0.5 * grillePattern);
                        }
                        
                        // FX Scanlines
                        float scanlineLvl = 0.8;
                        float scanlines = 1.0;
                        if (scanlineLvl > 0.05) {
                            float scanlinePattern = sin(vTextureCoord.y * iResolution.y * 3.14159 / scanlines);
                            color *= (scanlineLvl + (1.0 - scanlineLvl) * scanlinePattern);
                        }
                        
                        // FX Screen tint
                        float screenTint = 0.2;
                        float screenHue = 0.0;
                        float screenSat = 1.0;
                        if (screenTint > 0.0) {
                            float l = dot(color, vec3(0.2126, 0.7152, 0.0722));
                            vec3 screen = hsl2rgb(vec3(screenHue, screenSat, l));
                            color = mix(color, screen, screenTint);
                        }
                        
                        // FX Glass tint
                        float glassTint = 0.2;
                        float glassHue = 0.6;
                        float glassSat = 0.3;
                        if (glassTint > 0.0) {
                            float t = 0.5 + 0.5 * vTextureCoord.y;
                            vec3 tintColor = hsl2rgb(vec3(glassHue, glassSat, t));
                            color += tintColor * glassTint;
                        }
                        
                        // FX Flicker
                        float flicker = 0.05;
                        if (flicker > 0.0) {
                            float f = 1.0 + 0.25 * sin(iTime * 60.0) * flicker;
                            color *= f;
                        }
                        
                        // FX Vignette
                        vec2 vignetteUV = vTextureCoord;
                        vignetteUV *= (1.0 - vignetteUV.yx);
                        color *= pow(vignetteUV.x * vignetteUV.y * 20.0, 0.25);
                        
                        // FX Light Source
                        float lightSpeed = 1.0;
                        if (lightSpeed > 0.0) {
                            float lightFactor = calculateLightFactor(vTextureCoord, iTime * lightSpeed);
                            vec3 lightColor = vec3(1.0, 0.98, 0.95);
                            color *= lightColor * lightFactor;
                        }
                        
                        color -= rumbleDim;
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `;
                
                super(null, fragmentShader, {
                    uTime: 0.0,
                    uResolution: [1080, 2400]
                });
            }
            
            apply(filterManager, input, output, clearMode) {
                this.uniforms.uTime = performance.now() / 1000;
                this.uniforms.uResolution[0] = input.filterFrame.width;
                this.uniforms.uResolution[1] = input.filterFrame.height;
                
                filterManager.applyFilter(this, input, output, clearMode);
            }
        }

        // Seeded random number generator
        class SeededRandom {
            constructor(seed) {
                this.seed = seed;
            }
            
            next() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }
            
            randInt(min, max) {
                return Math.floor(this.next() * (max - min + 1)) + min;
            }
            
            randFloat(min, max) {
                return this.next() * (max - min) + min;
            }
        }

        class BinaryRainGame {
            constructor() {
                this.audioStarted = false;
                
                // Audio setup
                this.sounds = {
                    splish: null,
                    explosion: null
                };
                this.loadSounds();
                
                // Get seed from URL parameter or generate random one
                const urlParams = new URLSearchParams(window.location.search);
                this.seed = urlParams.get('seed') ? parseInt(urlParams.get('seed')) : Math.floor(Math.random() * 1000000);
                this.rng = new SeededRandom(this.seed);
                
                // Game constants
                this.BASE_WIDTH = 1080;
                this.BASE_HEIGHT = 2400;
                this.STRAIN_MIN_SIZE = 3;
                this.STRAIN_MAX_SIZE = 6;
                this.MIN_BASE_SPEED = 100;
                this.MAX_BASE_SPEED = 160;
                this.TOTAL_STRAINS = 20;
                this.TOTAL_RAINDROPS = 120;
                this.BASE_DIGIT_SIZE = 80;

                // Scale factor
                this.scale = 1;
                this.width = this.BASE_WIDTH;
                this.height = this.BASE_HEIGHT;
                this.digitSize = this.BASE_DIGIT_SIZE;
                
                // Game state
                this.gameMode = "start";
                this.score = 0;
                this.strains = [];
                this.raindrops = [];
                this.explosions = [];
                
                this.lastTime = 0;
                this.animTime = 0;
                
                this.init();
            }

            init() {
                // Calculate initial size but don't update UI yet
                const windowHeight = window.innerHeight - 20;
                const windowWidth = window.innerWidth - 20;
                
                const scaleByHeight = windowHeight / this.BASE_HEIGHT;
                const scaleByWidth = windowWidth / this.BASE_WIDTH;
                this.scale = Math.min(scaleByHeight, scaleByWidth);
                
                this.width = this.BASE_WIDTH * this.scale;
                this.height = this.BASE_HEIGHT * this.scale;
                this.digitSize = this.BASE_DIGIT_SIZE * this.scale;
                
                // Create PixiJS application
                this.app = new PIXI.Application({
                    width: this.width,
                    height: this.height,
                    backgroundColor: 0x000000,
                    antialias: true
                });
                
                document.getElementById('gameContainer').appendChild(this.app.view);
                
                // Create containers for different layers
                this.raindropContainer = new PIXI.Container();
                this.strainContainer = new PIXI.Container();
                this.explosionContainer = new PIXI.Container();
                this.uiContainer = new PIXI.Container();
                
                this.app.stage.addChild(this.raindropContainer);
                this.app.stage.addChild(this.strainContainer);
                this.app.stage.addChild(this.explosionContainer);
                this.app.stage.addChild(this.uiContainer);
                
                // Add CRT filter to the entire stage
                this.crtFilter = new CRTFilter();
                this.crtFilter.padding = 50;
                this.app.stage.filters = [this.crtFilter];
                
                // Wait for font to load before creating text objects
                document.fonts.ready.then(() => {
                    this.createUIElements();
                    this.setupInputHandlers();
                    this.updateURL();
                    this.updateUIPositions();
                    this.app.ticker.add((delta) => this.gameLoop(delta));
                    
                    console.log(`Game seed: ${this.seed}`);
                    console.log(`Share this game: ${window.location.origin}${window.location.pathname}?seed=${this.seed}`);
                });
            }
            
            createUIElements() {
                // Create UI text objects
                this.scoreText = new PIXI.Text('0', {
                    fontFamily: 'Monomaniac One, Courier New',
                    fontSize: 80,
                    fill: 0xffff00,
                    align: 'right'
                });
                this.scoreText.anchor.set(1, 0);
                this.uiContainer.addChild(this.scoreText);
                
                this.titleText = new PIXI.Text('0RA1N', {
                    fontFamily: 'Monomaniac One, Courier New',
                    fontSize: 200,
                    fill: 0x808080,
                    align: 'center'
                });
                this.titleText.anchor.set(0.5, 0.5);
                this.uiContainer.addChild(this.titleText);
                
                this.startText = new PIXI.Text('[S]tart', {
                    fontFamily: 'Monomaniac One, Courier New',
                    fontSize: 80,
                    fill: 0x00ffff,
                    align: 'center'
                });
                this.startText.anchor.set(0.5, 0.5);
                this.uiContainer.addChild(this.startText);
                
                this.seedText = new PIXI.Text(`Seed: ${this.seed}`, {
                    fontFamily: 'Monomaniac One, Courier New',
                    fontSize: 80,
                    fill: 0x00ffff,
                    align: 'center'
                });
                this.seedText.anchor.set(0.5, 0.5);
                this.uiContainer.addChild(this.seedText);
                
                this.restartText = new PIXI.Text('[R]estart with', {
                    fontFamily: 'Monomaniac One, Courier New',
                    fontSize: 80,
                    fill: 0x00ffff,
                    align: 'center'
                });
                this.restartText.anchor.set(0.5, 0.5);
                this.uiContainer.addChild(this.restartText);
            }
            
            setupInputHandlers() {
                // Input handlers
                document.addEventListener('keydown', (e) => this.handleInput(e));
                this.app.view.addEventListener('click', (e) => this.handleTap(e));
                this.app.view.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handleTap(touch);
                }, { passive: false });
                
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            loadSounds() {
                const loadSound = (filename) => {
                    return new Promise((resolve) => {
                        const audio = new Audio();
                        audio.addEventListener('canplaythrough', () => resolve(audio), { once: true });
                        audio.addEventListener('error', () => resolve(null), { once: true });
                        audio.src = `./${filename}`;
                        audio.load();
                    });
                };
                
                loadSound('fx-rain.ogg').then(audio => {
                    this.sounds.rain = audio;
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    fetch('./fx-rain.ogg')
                        .then(response => response.arrayBuffer())
                        .then(data => this.audioContext.decodeAudioData(data))
                        .then(buffer => {
                            this.rainBuffer = buffer;
                            if (audio) {
                                audio.loop = true;
                                audio.volume = 0.3;
                            }
                        })
                        .catch(console.error);
                });

                loadSound('music.ogg').then(audio => {
                    this.sounds.music = audio;
                    if (audio) {
                        audio.loop = true;
                        audio.volume = 0.5;
                    }
                });

                loadSound('fx-splish.ogg').then(audio => {
                    this.sounds.splish = audio;
                });
                
                loadSound('fx-explosion.ogg').then(audio => {
                    this.sounds.explosion = audio;
                });

                loadSound('fx-huh.ogg').then(audio => {
                    this.sounds.gameover = audio;
                });
            }

            startAudio() {
                if (!this.audioStarted) {
                    if (this.rainBuffer && this.audioContext) {
                        this.rainSource = this.audioContext.createBufferSource();
                        this.rainSource.buffer = this.rainBuffer;
                        this.rainSource.loop = true;
                        
                        const gainNode = this.audioContext.createGain();
                        gainNode.gain.value = 0.3;
                        
                        this.rainSource.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        this.rainSource.start(0);
                        this.audioStarted = true;
                    } else if (this.sounds.rain) {
                        this.sounds.rain.play().catch(console.error);
                        this.audioStarted = true;
                    }
                }
            }

            startGameMusic() {
                if (this.sounds.music && this.sounds.music.paused) {
                    this.sounds.music.play().catch(() => {});
                }
            }

            stopGameMusic() {
                if (this.sounds.music && !this.sounds.music.paused) {
                    this.sounds.music.pause();
                    this.sounds.music.currentTime = 0;
                }
            }
            
            playSound(soundName) {
                const sound = this.sounds[soundName];
                if (sound) {
                    sound.currentTime = 0;
                    sound.play().catch(() => {});
                }
            }

            handleTap(pos) {
                const rect = this.app.view.getBoundingClientRect();
                const x = pos.clientX - rect.left;
                const y = pos.clientY - rect.top;

                this.startAudio();

                if (this.gameMode === "start") {
                    this.startNewGame();
                    return;
                }

                if (this.gameMode === "gameover") {
                    const centerY = this.height / 2;
                    if (y < centerY + 80) {
                        this.startNewGame();
                    } else {
                        this.restart();
                    }
                    return;
                }

                if (this.gameMode !== "play") return;

                if (x < this.width / 2) {
                    this.handleVirtualKey("1");
                } else {
                    this.handleVirtualKey("0");
                }
            }

            handleVirtualKey(key) {
                for (const strain of this.strains) {
                    if (strain.destroyTimer > 0) continue;

                    const currentDigit = strain.digits[strain.highlight];
                    if (key === currentDigit.value) {
                        strain.highlight--;
                        this.playSound('splish');
                        this.createSuccessEffect(strain.x, strain.getHighlightY());

                        if (strain.highlight < 0) {
                            this.scoreUp(strain);
                        }
                    } else {
                        strain.reset();
                    }
                }
            }
            
            updateURL() {
                const url = new URL(window.location);
                url.searchParams.set('seed', this.seed);
                window.history.replaceState({}, '', url);
            }
            
            startNewGame() {
                this.startGameMusic();
                this.seed = Math.floor(Math.random() * 1000000);
                this.rng = new SeededRandom(this.seed);
                this.updateURL();
                this.gameMode = "play";
                this.score = 0;
                this.strains = [];
                this.explosions = [];
                this.strainContainer.removeChildren();
                this.explosionContainer.removeChildren();
                this.seedText.text = `Seed: ${this.seed}`;
                console.log(`New game seed: ${this.seed}`);
            }
            
            resizeCanvas() {
                const windowHeight = window.innerHeight - 20;
                const windowWidth = window.innerWidth - 20;
                
                const scaleByHeight = windowHeight / this.BASE_HEIGHT;
                const scaleByWidth = windowWidth / this.BASE_WIDTH;
                this.scale = Math.min(scaleByHeight, scaleByWidth);
                
                this.width = this.BASE_WIDTH * this.scale;
                this.height = this.BASE_HEIGHT * this.scale;
                this.digitSize = this.BASE_DIGIT_SIZE * this.scale;
                
                if (this.app) {
                    this.app.renderer.resize(this.width, this.height);
                    this.updateUIPositions();
                }
            }
            
            updateUIPositions() {
                if (!this.scoreText) return; // Guard against early calls
                
                this.scoreText.x = this.width - 20;
                this.scoreText.y = this.height - 40;
                this.scoreText.style.fontSize = 80 * this.scale;
                
                this.titleText.x = this.width / 2;
                this.titleText.y = this.height / 2 - 150 * this.scale;
                this.titleText.style.fontSize = 200 * this.scale;
                
                this.startText.x = this.width / 2;
                this.startText.y = this.height / 2;
                this.startText.style.fontSize = 80 * this.scale;
                
                this.restartText.x = this.width / 2;
                this.restartText.y = this.height / 2;
                this.restartText.style.fontSize = 80 * this.scale;
                
                this.seedText.x = this.width / 2;
                this.seedText.y = this.height / 2 + 80 * this.scale;
                this.seedText.style.fontSize = 80 * this.scale;
            }
            
            findValidX() {
                const pixels = new Array(Math.floor(this.width)).fill(true);
                
                for (const strain of this.strains) {
                    const maxX = Math.min(strain.x + this.digitSize, this.width);
                    for (let i = strain.x; i < maxX; i++) {
                        if (strain.getY() < this.height / 2) {
                            pixels[i] = false;
                        }
                    }
                }
                
                const possibles = [];
                for (let x = 0; x < pixels.length; x++) {
                    if (this.isValidPosition(pixels, x)) {
                        possibles.push(x);
                    }
                }
                
                if (possibles.length === 0) return -1;
                return possibles[this.rng.randInt(0, possibles.length - 1)];
            }
            
            isValidPosition(pixels, x) {
                if (x > this.width - this.digitSize) return false;
                
                for (let i = x; i < x + this.digitSize; i++) {
                    if (i >= pixels.length || !pixels[i]) return false;
                }
                return true;
            }
            
            handleInput(event) {
                this.startAudio();
                if (this.gameMode === "start") {
                    if (event.key.toLowerCase() === 's') {
                        this.startNewGame();
                    }
                    return;
                }
                
                if (this.gameMode === "gameover") {
                    if (event.key.toLowerCase() === 'r') {
                        this.restart();
                    } else if (event.key.toLowerCase() === 's') {
                        this.startNewGame();
                    }
                    return;
                }
                
                if (this.gameMode !== "play") return;
                
                let key = event.key;
                
                if (key === 'Numpad0') key = '0';
                if (key === 'Numpad1') key = '1';
                
                if (key === '0' || key === '1') {
                    for (const strain of this.strains) {
                        if (strain.destroyTimer > 0) continue;
                        
                        const currentDigit = strain.digits[strain.highlight];
                        if (key === currentDigit.value) {
                            strain.highlight--;
                            this.playSound('splish');
                            this.createSuccessEffect(strain.x, strain.getHighlightY());
                            
                            if (strain.highlight < 0) {
                                this.scoreUp(strain);
                            }
                        } else {
                            strain.reset();
                        }
                    }
                }
            }
            
            createSuccessEffect(x, y) {
                this.explosions.push(new Explosion(x, y, '+1', this.explosionContainer, this.digitSize));
            }
            
            scoreUp(strain) {
                this.score += strain.strainSize;
                strain.destroyTimer = 0.35;
                
                this.playSound('explosion');
                
                for (const digit of strain.digits) {
                    this.explosions.push(new Explosion(digit.x, digit.y, '•', this.explosionContainer, this.digitSize));
                }
            }
            
            restart() {
                this.rng = new SeededRandom(this.seed);
                this.gameMode = "play";
                this.score = 0;
                this.strains = [];
                this.explosions = [];
                this.strainContainer.removeChildren();
                this.explosionContainer.removeChildren();
                this.startGameMusic();
            }
            
            gameOver() {
                this.gameMode = "gameover";
                this.stopGameMusic();
                this.playSound('gameover');
                
                for (const strain of this.strains) {
                    if (strain.destroyTimer <= 0) {
                        strain.destroyTimer = 0.35;
                        
                        for (const digit of strain.digits) {
                            this.explosions.push(new Explosion(digit.x, digit.y, '•', this.explosionContainer, this.digitSize));
                        }
                    }
                }
            }
            
            update(deltaTime) {
                this.animTime += deltaTime;
                
                // Update explosions
                for (let i = this.explosions.length - 1; i >= 0; i--) {
                    this.explosions[i].update(deltaTime);
                    if (this.explosions[i].alpha <= 0) {
                        this.explosions[i].destroy();
                        this.explosions.splice(i, 1);
                    }
                }
                
                // Update strains
                for (let i = this.strains.length - 1; i >= 0; i--) {
                    const strain = this.strains[i];
                    strain.update(deltaTime, this.height, this.animTime);
                    
                    if (strain.destroyTimer === 0) {
                        strain.destroy();
                        this.strains.splice(i, 1);
                    } else if (strain.gameover && this.gameMode === "play") {
                        this.gameOver();
                        return;
                    }
                }
                
                // Create raindrops
                while (this.raindrops.length < this.TOTAL_RAINDROPS) {
                    this.raindrops.push(new Raindrop(this.width, this.height, this.digitSize, this.rng, this.raindropContainer));
                }
                
                // Update raindrops
                for (const raindrop of this.raindrops) {
                    raindrop.update(deltaTime);
                }
                
                if (this.gameMode !== "play") return;
                
                // Create new strains
                while (this.strains.length < this.TOTAL_STRAINS) {
                    let x = this.rng.randInt(0, this.width - this.digitSize);
                    if (this.strains.length > 1) {
                        x = this.findValidX();
                    }
                    if (x > -1) {
                        this.strains.push(new Strain(x, this.STRAIN_MIN_SIZE, this.STRAIN_MAX_SIZE, 
                        this.MIN_BASE_SPEED, this.MAX_BASE_SPEED, this.digitSize, this.scale, this.rng, this.strainContainer));
                    } else {
                        break;
                    }
                }
            }
            
            render() {
                // Update UI
                this.scoreText.text = this.score.toString();
                
                // Show/hide UI elements based on game mode
                this.titleText.visible = (this.gameMode === "start" || this.gameMode === "gameover");
                this.startText.visible = (this.gameMode === "start" || this.gameMode === "gameover");
                this.seedText.visible = (this.gameMode === "start" || this.gameMode === "gameover");
                this.restartText.visible = (this.gameMode === "gameover");
                
                if (this.gameMode === "gameover") {
                    this.seedText.y = this.height / 2 + 40 * this.scale;
                } else {
                    this.seedText.y = this.height / 2 + 80 * this.scale;
                }
            }
            
            gameLoop(delta) {
                const deltaTime = delta / 60; // Convert to seconds
                
                this.update(deltaTime);
                this.render();
            }
        }
        
        class Strain {
            constructor(x, minSize, maxSize, minSpeed, maxSpeed, digitSize, scale, rng, container) {
                this.x = x;
                this.speed = (rng.randFloat(minSpeed, maxSpeed)) * scale;
                this.strainSize = rng.randInt(minSize, maxSize);
                this.gameover = false;
                this.destroyTimer = -1;
                this.digits = [];
                this.highlight = this.strainSize - 1;
                this.currentAnim = this.strainSize;
                this.animMultiplier = rng.randFloat(4, 12);
                this.digitSize = digitSize;
                this.container = container;
                
                // Create digits with PixiJS Text
                for (let i = 0; i < this.strainSize; i++) {
                    const value = rng.next() < 0.5 ? '0' : '1';
                    const text = new PIXI.Text(value, {
                        fontFamily: 'Monomaniac One, Courier New',
                        fontSize: digitSize,
                        fill: 0x00ffff,
                        align: 'left'
                    });
                    text.x = x;
                    text.y = (i * digitSize) - this.strainSize * digitSize;
                    text.alpha = 0.3;
                    
                    this.digits.push({
                        value: value,
                        x: x,
                        y: text.y,
                        sprite: text
                    });
                    
                    container.addChild(text);
                }
            }
            
            getY() {
                return this.digits[0].y;
            }
            
            getHighlightY() {
                return this.digits[this.highlight] ? this.digits[this.highlight].y : this.getY();
            }
            
            reset() {
                this.highlight = this.strainSize - 1;
            }
            
            update(deltaTime, windowHeight, globalAnimTime) {
                this.currentAnim += deltaTime * this.animMultiplier;
                if (this.currentAnim > this.strainSize) {
                    this.currentAnim = 0;
                }
                
                for (let i = 0; i < this.digits.length; i++) {
                    const digit = this.digits[i];
                    digit.y += this.speed * deltaTime;
                    digit.x += (Math.random() - 0.5) * 0.05;
                    
                    // Update sprite position
                    digit.sprite.x = digit.x;
                    digit.sprite.y = digit.y;
                    
                    if (this.destroyTimer > 0) {
                        digit.y += (Math.random() - 0.5) * 10;
                        digit.x += (Math.random() - 0.5) * 10;
                        digit.sprite.x = digit.x;
                        digit.sprite.y = digit.y;
                        this.destroyTimer -= 0.0025;
                        if (this.destroyTimer < 0) {
                            this.destroyTimer = 0;
                        }
                    }
                    
                    // Update color and alpha
                    const baseAlpha = 0.3 * (this.destroyTimer > 0 ? this.destroyTimer : 1);
                    let alpha = baseAlpha;
                    
                    if (i > this.highlight) {
                        digit.sprite.style.fill = 0xffffff;
                        digit.sprite.alpha = 0.75 * (this.destroyTimer > 0 ? this.destroyTimer : 1);
                    } else {
                        digit.sprite.style.fill = 0x00ffff;
                        if (i === Math.floor(this.currentAnim)) {
                            alpha = baseAlpha + 0.2;
                        }
                        if (i === this.strainSize - 1) {
                            alpha += 0.2;
                        }
                        digit.sprite.alpha = alpha;
                    }
                    
                    if (digit.y > windowHeight && !this.gameover) {
                        this.gameover = true;
                    }
                }
            }
            
            destroy() {
                for (const digit of this.digits) {
                    this.container.removeChild(digit.sprite);
                    digit.sprite.destroy();
                }
            }
        }
        
        class Raindrop {
            constructor(windowWidth, windowHeight, digitSize, rng, container) {
                this.windowWidth = windowWidth;
                this.windowHeight = windowHeight;
                this.digitSize = digitSize;
                this.speed = rng.randFloat(300, 700);
                this.rng = rng;
                this.container = container;
                
                this.sprite = new PIXI.Text('•', {
                    fontFamily: 'Monomaniac One, Courier New',
                    fontSize: digitSize,
                    fill: 0x0a0a0a,
                    align: 'left'
                });
                
                container.addChild(this.sprite);
                this.reset();
            }
            
            reset() {
                this.x = this.rng.randFloat(0, this.windowWidth - this.digitSize);
                this.y = -this.digitSize;
                this.sprite.x = this.x;
                this.sprite.y = this.y;
                const brightness = this.rng.randInt(1, 10);
                this.sprite.style.fill = (brightness << 16) | (brightness << 8) | brightness;
            }
            
            update(deltaTime) {
                this.y += this.speed * deltaTime;
                if (this.y > this.windowHeight) {
                    this.reset();
                } else {
                    this.sprite.y = this.y;
                }
            }
        }
        
        class Explosion {
            constructor(x, y, char, container, fontSize) {
                this.x = x;
                this.y = y;
                this.alpha = 0.75;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.container = container;
                
                this.sprite = new PIXI.Text(char, {
                    fontFamily: 'Monomaniac One, Courier New',
                    fontSize: fontSize,
                    fill: 0xffffff,
                    align: 'left'
                });
                this.sprite.x = x;
                this.sprite.y = y;
                this.sprite.alpha = this.alpha;
                
                container.addChild(this.sprite);
            }
            
            update(deltaTime) {
                this.x += this.vx;
                this.y += this.vy;
                this.alpha -= 0.025;
                
                this.sprite.x = this.x;
                this.sprite.y = this.y;
                this.sprite.alpha = Math.max(0, this.alpha);
            }
            
            destroy() {
                this.container.removeChild(this.sprite);
                this.sprite.destroy();
            }
        }
        
        // Start the game
        const game = new BinaryRainGame();

        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./worker.js')
            .then(reg => console.log('Service Worker registered:', reg.scope))
            .catch(err => console.error('Service Worker registration failed:', err));
        });
        }
    </script>
</body>
</html>